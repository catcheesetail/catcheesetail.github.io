---
layout:     post
title:      定时器 你真的会使用吗？
subtitle:   iOS定时器详解
date:       2016-12-13
author:     BY
header-img: img/post-bg-ios9-web.jpg
catalog: 	 true
tags:
    - JS_Advance
---
### 原型与原型链
一、原型(prototype)
1. 函数的prototype属性
    - 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)
    - 原型对象中有一个属性constructor, 它指向函数对象
2. 给原型对象添加属性(一般都是方法)
   - 作用: 函数的所有实例对象自动拥有原型中的属性(方法)

二、显式原型与隐式原型
1. 每个函数function都有一个prototype，即显式原型
2. 每个实例对象都有一个__proto__，可称为隐式原型
3. 对象的隐式原型的值为其对应构造函数的显式原型的值
4. 内存结构(图)
5. 总结:
    - 函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象
    - 对象的__proto__属性:创建对象时自动添加的,默认值为构造函数的prototype属性值
    - 程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)
    - 如果通过一个实例对象改变了原型对象中的属性，其他实例访问到的也是修改后的属性

**注意：通过构造函数创建的实例无法找到Function的prototype------仅限于原型链，通过constructor则可以找到**

三、原型链
1. 原型链
    - 访问一个对象的属性时，先在自身属性中查找，找到返回
    - 如果没有, 再沿着__proto__这条链向上查找, 找到返回
    - 如果最终没找到, 返回undefined
       - 别名: 隐式原型链
       - 作用: 查找对象的属性(方法)
2. 构造函数/原型/实体对象的关系(图解)

3. 构造函数/原型/实体对象的关系2(图解)

四、原型链_属性问题
1. 读取对象的属性值时: 会自动到原型链中查找
2. 设置对象的属性值时:不会查找原型链,如果当前对象中没有此属性,直接添加此属性并设置其值
3. 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上

五、探索instanceof
1. instanceof是如何判断的?
    - 表达式: A instanceof B
    - 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false
  
2. Function是通过new自己产生的实例
* `注意：所有函数的--proto--都是一样的，都指向Function的prototype`


六、面试题与思考
```
/*
  测试题1
   */
  var A = function() {

  }
  A.prototype.n = 1
  var b = new A()
  A.prototype = {
    n: 2,
    m: 3
  }
  var c = new A()
  console.log(b.n, b.m, c.n, c.m)//1 undefined 2 3

  /*
   测试题2
   */
  var F = function(){};
  Object.prototype.a = function(){
    console.log('a()')
  };
  Function.prototype.b = function(){
    console.log('b()')
  };
  var f = new F();
  f.a()//a()
//  f.b() //is  not a function
  F.a()//a()
  F.b()//b()
  ```

### 执行上下文与执行上下文栈
一、变量提升与函数提升
1. 变量声明提升
    - 通过var定义(声明)的变量, 在定义语句之前就可以访问到
    - 值: undefined
2. 函数声明提升
    - 通过function声明的函数, 在声明函数之前就可以直接调用
    - 值: 函数定义(对象)

3. 问题: 变量提升和函数提升是如何产生的?

    `注意：函数提升的优先级高于变量<==>函数提升后于变量提升`

二、执行上下文
1. 代码分类(位置)
    - 全局代码
    - 函数代码
2. 全局执行上下文
    - 在执行全局代码前将window确定为全局执行上下文
    - 对全局数据进行预处理
        - var定义的全局变量==>undefined, 添加为window的属性
        - function声明的全局函数==>赋值(fun), 添加为window的方法
        - this==>赋值(window)
        - 开始执行全局代码
3. 函数执行上下文
    - 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象
    - 对局部数据进行预处理
        - 形参变量==>赋值(实参)==>添加为执行上下文的属性
        - arguments==>赋值(实参列表), 添加为执行上下文的属性
        - var定义的局部变量==>undefined, 添加为执行上下文的属性
        - function声明的函数 ==>赋值(fun), 添加为执行上下文的方法
        - this==>赋值(调用函数的对象)
        - 开始执行函数体代码

三、执行上下文栈
1. 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象
2. 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)
3. 在函数执行上下文创建后, 将其添加到栈中(压栈)
4. 在当前函数执行完后,将栈顶的对象移除(出栈)
5. 当所有的代码执行完后, 栈中只剩下window

- 例子
   1. 依次输出什么?
   2. 整个过程中产生了几个执行上下文?
        
```
console.log('global begin: '+ i)
        var i = 1
        foo(1);
        function foo(i) {
          if (i == 4) {
            return;
          }
          console.log('foo() begin:' + i);
          foo(i + 1);
          console.log('foo() end:' + i);
        }
        console.log('global end: ' + i)
```


四、面试题与思考

/*
测试题1: 先预处理变量, 后预处理函数
*/

     function a() {}
     var a;
     console.log(typeof a)


/*
测试题2: 变量预处理, in操作符
 */
 
    if (!(b in window)) {
      var b = 1;
    }
    console.log(b)

/*
测试题3: 预处理, 顺序执行
 */
 
    var c = 1
    function c(c) {
      console.log(c)
      var c = 3
    }
    c(2)

### 作用域与作用域链
一、作用域
1. 理解
      - 就是一块"地盘", 一个代码段所在的区域
      - 它是静态的(相对于上下文对象), 在编写代码时就确定了
2. 分类
    - 全局作用域
    - 函数作用域
    - 没有块作用域(ES6有了)
3. 作用
    
    `隔离变量，不同作用域下同名变量不会有冲突`

二、作用域与执行上下文
1. 区别1
    - 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时
    - 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建
    - 函数执行上下文环境是在调用函数时, 函数体代码执行之前创建
2. 区别2
    - 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化
    - 上下文环境是动态的, 调用函数时创建, 
    - 函数调用结束时上下文环境就会被释放
3. 联系
    - 上下文环境(对象)是从属于所在的作用域
    - 全局上下文环境==>全局作用域
    - 函数上下文环境==>对应的函数使用域

三、作用域链
1. 理解
    - 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)
    - 查找变量时就是沿着作用域链来查找的
2. 查找一个变量的查找规则
    - 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2
    - 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3
    - 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常

### 闭包
一、闭包
1. 如何产生闭包?
    - 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包
2. 闭包到底是什么?
    - 使用chrome调试查看
      - 理解一: 闭包是嵌套的内部函数(绝大部分人)
      - 理解二: 包含被引用变量(函数)的对象(极少数人)
      - 注意: 闭包存在于嵌套的内部函数中
3. 产生闭包的条件?
    - 函数嵌套
    - 内部函数引用了外部函数的数据(变量/函数)

二、常见的闭包
    - 将函数作为另一个函数的返回值
    - 将函数作为实参传递给另一个函数调用

三、闭包的作用
1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)
2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)
    问题:
    - 函数执行完后, 函数内部声明的局部变量是否还存在?一般不存在，但是存在闭包中的变量存在
    - 在函数外部能直接访问函数内部的局部变量吗?不能，作用域封闭

四、闭包的生命周期
- 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)
- 死亡: 在嵌套的内部函数成为垃圾对象时

五、闭包的应用
    
- 定义JS模块
  * 具有特定功能的js文件
  * 将所有的数据和功能都封装在一个函数内部(私有的)
  * 只向外暴露一个包信n个方法的对象或函数
  * 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能

六、缺点及解决

1. 缺点
  * 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长
  * 容易造成内存泄露
2. 解决
  * 能不用闭包就不用
  * 及时释放

七、面试题

	//代码片段一
    var name = "The Window";
    var object = {
      name : "My Object",
      getNameFunc : function(){
        return function(){
          return this.name;
        };
      }
    };
    alert(object.getNameFunc()());  //? The Window 没有闭包

    //代码片段二
    var name2 = "The Window";
    var object2 = {
      name2 : "My Object",
      getNameFunc : function(){
        var that = this;
        return function(){
          return that.name2;
        };
      }
    };
    alert(object2.getNameFunc()()); //? My Object that存在于闭包中

    //代码片段三
     function fun(n,o) {
       console.log(o)
       return {
         fun:function(m){
           return fun(m,n);
         }
       };
     }
     var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?
     /*  n=0 o=undefined//undefined
     m=1 n=0 n=m=1 o=n=0//0
     m=2 n=0 n=m=2 o=n=0//0
     m=3 n=0 n=m=3 o=n=0//0*/
    
     var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?
    /*   n=0 o=undefined //undefined
     m=1 n=0 赋值:n=m=1 o=n=0//0
     m=2 n=1 赋值:n=m=2 o=n=1//1
     m=3 n=2 赋值:n=m=3 o=n=2//2*/
     var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?
     /*n=0 o=undefined//undefined
     m=1 n=0 赋值:n=m=1 o=n=0//0
    
     //n=m=1 o=n=0
     m=2 n=1 赋值:n=m=1 o=n=1//1
     //n=m=1 o=n=0
     m=3 n=1 赋值:n=m=3 o=n=1//1*/

